-- 비등가 조인 (Non-Equi Join)
SELECT * FROM T_CUSTOMER;
SELECT * FROM T_GIFT;

-- #6201
-- ORACLE
SELECT C.C_NAME "고객명", C.C_POINT "POINT", G.G_NAME "상품명"
FROM T_CUSTOMER C, T_GIFT G
WHERE C.C_POINT BETWEEN G.G_START AND G.G_END;

-- ANSI
SELECT C.C_NAME "고객명", C.C_POINT "POINT", G.G_NAME "상품명"
FROM T_CUSTOMER C JOIN T_GIFT G
	 ON C.C_POINT BETWEEN G.G_START AND G.G_END;
	
-- #6202
SELECT G.G_NAME "상품명", COUNT(*) "필요수량"
FROM T_CUSTOMER C, T_GIFT G
WHERE C.C_POINT BETWEEN G.G_START AND G.G_END
GROUP BY G.G_NAME;

SELECT G.G_NAME "상품명", COUNT(*) "필요수량"
FROM T_CUSTOMER C JOIN T_GIFT G
	 ON C.C_POINT BETWEEN G.G_START AND G.G_END
GROUP BY G.G_NAME;

-- #6203
SELECT * FROM T_STUDENT;
SELECT * FROM T_EXAM01;
SELECT * FROM T_CREDIT;

SELECT S.NAME 학생이름, E.TOTAL 점수, C.GRADE 학점
FROM T_STUDENT S, T_EXAM01 E, T_CREDIT C
WHERE S.STUDNO = E.STUDNO AND 
	  E.TOTAL BETWEEN C.MIN_POINT AND C.MAX_POINT;

SELECT S.NAME 학생이름, E.TOTAL 점수, C.GRADE 학점
FROM T_STUDENT S 
	 JOIN T_EXAM01 E ON S.STUDNO = E.STUDNO
	 JOIN T_CREDIT C ON E.TOTAL BETWEEN C.MIN_POINT AND C.MAX_POINT;

SELECT C.C_NAME "고객명", C.C_POINT "뽀인트", G.G_NAME "상품명"
FROM T_CUSTOMER C, T_GIFT G
WHERE C.C_POINT >= G.G_START AND G.G_NAME = '산악용자전거';

SELECT C.C_NAME "고객명", C.C_POINT "뽀인트", G.G_NAME "상품명"
FROM T_CUSTOMER C JOIN T_GIFT G
	 ON C.C_POINT >= G.G_START AND G.G_NAME = '산악용자전거';

-- #6205
-- ORACLE
SELECT E.NAME "이름",
	   (TO_CHAR(SYSDATE, 'YYYY') - TO_CHAR(E.BIRTHDAY, 'YYYY') + 1) "현재나이",
	   NVL(E.POST, ' ') "현재직급", P.POST "예상직급"
FROM T_EMP2 E, T_POST P
WHERE (TO_CHAR(SYSDATE, 'YYYY') - TO_CHAR(E.BIRTHDAY, 'YYYY') + 1)
	  BETWEEN P.S_AGE AND P.E_AGE;

-- ANSI
SELECT E.NAME "이름",
	   (TO_CHAR(SYSDATE, 'YYYY') - TO_CHAR(E.BIRTHDAY, 'YYYY') + 1) "현재나이",
	   NVL(E.POST, ' ') "현재직급", P.POST "예상직급"
FROM T_EMP2 E JOIN T_POST P
	 ON (TO_CHAR(SYSDATE, 'YYYY') - TO_CHAR(E.BIRTHDAY, 'YYYY') + 1)
	 BETWEEN P.S_AGE AND P.E_AGE;

-- #6206
-- t_student 테이블과 t_professor 테이블 Join 하여
-- 학생이름과 지도교수 이름을 출력하세요. 단! 지도교수가 결정되지 않은 학생의 명단도 함께 출력하세요
SELECT * FROM T_STUDENT;
SELECT * FROM T_PROFESSOR;

SELECT S.NAME 학생이름, P.NAME 교수이름
FROM T_STUDENT S LEFT OUTER JOIN T_PROFESSOR P
	 ON S.PROFNO = P.PROFNO;

-- #6207 t_student, t_professor 테이블 join
-- 학생이름과 지도교수 이름을 출력, 단! 지도 학생이 결정되지 않은 교수 명단도 출력
SELECT S.NAME 학생이름, P.NAME 교수이름
FROM T_STUDENT S RIGHT OUTER JOIN T_PROFESSOR P
	 ON S.PROFNO = P.PROFNO;

-- #6208
-- t_student, t_professor 테이블 join
-- 학생이름과 지도교수 이름을 출력,
-- 단! 지도 학생이 결정되지 않은 교수 명단, 지도교수가 결정되지 않은 학생명단 모두 출력
SELECT S.NAME 학생이름, P.NAME 교수이름
FROM T_STUDENT S FULL OUTER JOIN T_PROFESSOR P
	 ON S.PROFNO = P.PROFNO;

-- #6209
-- t_dept2 테이블에서 부서명 과 그 부서의 상위부서명을 출력하세요
-- ORACLE
SELECT D1.DNAME 부서명, D2.DNAME 상위부서명
FROM T_DEPT2 D1, T_DEPT2 D2
WHERE D1.PDEPT = D2.DCODE;

-- ANSI
SELECT D1.DNAME "부서명", D2.DNAME "상위부서명"
FROM T_DEPT2 D1 JOIN T_DEPT2 D2
	 ON D1.PDEPT = D2.DCODE;
	
-- #6210 
-- t_professor 테이블
-- 교수번호, 교수이름, 입사일, 그리고 자신보다 입사일 빠른 사람의 인원수를 출력하세요,
-- 단 자신보다 입사일이 빠른 사람수를 오름차순으로 출력하세요
SELECT P1.PROFNO 교수번호, P1.NAME 교수명, TO_CHAR(P1.HIREDATE, 'YYYY-MM-DD') 입사일,
	   COUNT(P2.HIREDATE) "빠른사람" 
FROM T_PROFESSOR P1 LEFT OUTER JOIN T_PROFESSOR P2
	 ON P1.HIREDATE > P2.HIREDATE
GROUP BY P1.PROFNO, P1.NAME, P1.HIREDATE
ORDER BY "빠른사람";